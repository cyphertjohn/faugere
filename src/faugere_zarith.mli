module Fgb_int_zarith : sig

  val set_max_output_size : int -> unit
  (**Internally in fgb a buffer needs to be allocated to hold the output polynomials. The number of polynomials in the resulting GB cannot be larger than this value. Default is 100000.*)

  val set_index : int -> unit
  (**From the fgb doc. "This is is the maximal size of the matrices generated by F4
     you can increase this value according to your memory." Default is 500000.*)

  val set_fgb_verbosity : int -> unit
  (**Increase the verbosity of fgb. Default is 0 for least verbosity. 1 increases verbosity. Unfortunately, with 0 verbosity "open simulation" is still printed to stdout from somewhere in fgb. *)

  val set_force_elim : int -> unit
  (**If an elimination order is given to fgb and force_elim = 1, fgb will only return the polynomials in the elimination ideal. By default force_elim = 0.*)

  val set_number_of_threads : int -> unit
  (**Set the number of threads fgb will use. Default is 1.*)

  val fgb : (Z.t Faugere.fmon list) list -> string list -> string list -> (Z.t Faugere.fmon list) list
  (**See {!val:Faugere.Fgb_int_str.fgb}. [fgb polys block1 block2] computes a Grobner basis of the polynomials in [polys] within the ring Q\[block1, block2\]. 
  The monomial order used in the computation is a block ordering defined by the variables in [block1] and [block2] with [block1] >> [block2]. That is,
  for any monomials m1 and m2 where, m1 contains variables in [block1] but m2 does not, m1>m2. The monomial order within each block is degree reverse
  lexicographic defined by the order of the variables in the given list. That is [fgb polys \["x"; "y"; "z"\] \[\]] defines a drl order with [x] > [y] > [z].
  As in the previous example [block2] can be empty, indicated a normal drl order. However, [block1] must be non-empty. For the input polynomials to be 
  well formed the integer lists representing each monic monomial need to have the same length as [block1 @ block2]. *)

end

